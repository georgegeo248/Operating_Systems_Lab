1. Socket:
    Το socket ειναι το άκρο (endpoint) ενός
    καναλιού επικοινωνίας διεργασιών, οπου μεσα απο αυτο το κανάλι οι διεργασίες
    μπορούν να επικοινωνούν µε τις συνηθισμένες κλήσεις read() και write(). 
    Υπάρχει µια συγκεκριμένη διαδικασία δημιουργίας αυτού του
    καναλιού
    
    Για την δημιουργία ενος socket χρησιμοποιούμε την κληση συστήματος socket()
    
    !! Η δημιουργία ενός socket δεν συνεπάγεται και τη
    δημιουργία του καναλιού. !!
    Για να δημιουργληθεί ενα τετοιο κανάλι θα πρέπει δύο διεργασίες να δημιουργήσουν η κάθε µία
    ένα socket και έπειτα η µια από αυτές να περιμένει
    σύνδεση και η άλλη να τη ζητήσει.
    Ετσι η μία διεργασία ειναι ο client και η άλλη ειναι ο server.
    

2. System Call Socket:
    Δημιουργεί ενα ακρο επικοινωνίας και γυρνάει ενα file descriptor (που ειχαμε αναλύσει στο 
     	προηγούμενο εργατηστήριο) ο οποίος αναφέρεται σε αυτο το άκρο
    Αυτός ο file descriptor θα πάρει τον μικρότερο αιρθμό που ειναι διαθεσιμος 
    (συμφωνα με το manual)
    #include <sys/socket.h>
    int socket(int domain, int type, int protocol);
    3 Ορισματα:
	domain
		Ειναι το πεδίο απο το οποίο λαμβάνει "όνομα" το socket 
		Ουσιαστικά επιλέγει το protocol family το οποίο θα χρησιμοποιηθεί για  την 
			επικοινωνία
		Υπαρχουν αρκετά domain 
		AF_UNIX -> unix domain
		AF_INET -> Internet Domain 
		Εμεις χρησιμοποιούμε Internet Domain
	Type 
		Ειναι ενα int το οποίο προσδιορίζει τον τύπο της επικοινωνίας (συγκεκριμένα την 	
			σημασιολογία)
		Για παράδειγμα Stream Communication / Datagram Communication
		Εμείς χρησιμοποιούμε Stream communication αρα βάζουμε τον τύπο SOCK_STREAM
	Protocol
		Ειναι ενα int το οποίο προσδιορίζει το πρωτόκολλο το οποίο θα υλοποιήσει την 
		επικοινωνία στο συγκεκριμένο socket
		Εμεις βάλαμε την τιμή 0 ωστε να κάνει το σύστημα την επιλογή
    Return Value
	Στην επιτυχία γυρνάει εναν filedescriptor. Στην αποτυχία γυρνάει -1

3. Internet domain (AF_ΙΝΕΤ):
    Χρησιμοποιώντας αυτό το domain κάθε socket
    ταυτοποιείται από μια δυάδα που αποτελείται από την IP
    διεύθυνση (ΙΡ address) του συστήματος στο οποίο έχει
    δημιουργηθεί το socket και ένα θετικό ακέραιο ο οποίος 
    ονοµάζεται port number του socket και δηλώνει σε ποια
    “θύρα” επικοινωνίας μέσα στο σύστημα αυτό έχει
    “συνδεθεί” το socket

4. Ταυτοποίηση καναλιού επικοινωνίας
    Κάθε κανάλι επικοινωνίας
    ταυτοποιείται µονοσήμαντα µε την πεντάδα
    {πρωτόκολλο / τοπική μηχανή / τοπικό port /
    απομακρυσµένη μηχανή / απομακρυσμένο port}. 

	Tοπική Μηχανη -> Δηλαδή το IP 

5. Μετάδοση Δεδομένων:
    Stream communication (SOCK_STREAM)
    Τα δεδομένα στέλνονται πάνω σε ήδη υπάρχον κανάλι
        επικοινωνίας (για αυτό και ο συγκεκριμένος τρόπος
        ονομάζεται connection oriented).
    πρωτόκολλο επικοινωνίας = TCP 
        φροντίζει και αναλαμβάνει όλους τους
        ελέγχους για λάθη στη μετάδοση των δεδομένων καθώς
        και την επαναμετάδοση των πακέτων που χάθηκαν.
    Επομένως δεν ασχολούμαστε εμείς με αυτό
    
    
    Datagram communication (SOCK_DGRAM)
    	όπου τα δεδομένα μεταδίδονται σε μικρά αυτόνομα “πακέτα”
	που ονομάζονται datagrams και το κανάλι επικοινωνίας
	δημιουργείται για κάθε μήνυμα ξεχωριστά
	(connectionless), ενώ η παραλαβή του δεν είναι
	εγγυημένη. Ο έλεγχος µμετάδοσης µε τη σωστή σειρά και
	η ευθύνη για τον κατακερματισμό (fragmentation) και την
	επανασυναρμολόγηση (reassembly) των δεδομένων
	ανήκουν στις εφαρμογές. Με τον τρόπο αυτό, που
	αντιστοιχεί στο πρωτόκολλο επικοινωνίας UDP,
	επιτυγχάνονται υψηλές ταχύτητες μετάδοσης

6.bind:
	Οταν δημιοιυργείται ενα socket δεν έχει καποια διευθυνση που να του εχει ανατεθει. 
	Με χρήση της κλήσης bind() δίνεται διεύθυνση σε ένα socket:
	Η λειτουργία αυτή συνοψίζεται σε μια εκφραση που την ειδαμε αρκετα οσο δουλευαμε την 	
		ασκηση: assigning a name to a socket
	Ουσιαστικα συσχετίζει μια συγκεκτιμενη local IP addr και εναν port number με το socket.

	Η υλοποιηση αυτης της ενωσης γιενται με το system call bind()
	int bind(int socket, const struct sockaddr *address, socklen_t address_len);
	Βρισκεται στο header <sys/socket.h>
	H διευθυνση που χρησιμοποιεί  φαίνεται σε ενα sockaddr struct στο socket που 
	φτιάξαμε
	Parameters (3):
		socket: το socket descriptor που πηραμε απο προηγουμενη κληση της socket()
		address: ενας δεικτης σε struct sockaddr που περιεχει το ονομα που θα δωσουμε στο 
			socket.
		address_len: ειναι το μεγεθος της διευθυνσης σε bytes.
	Επιστρεφει:
		Στην επιτυχια επιστρεφει 0
		Στην αποτυχια επιστρεφει -1 
 
	*** Δικια μας περιπτωση
	bind(CL_SOCKET, (struct sockaddr *)&sin, sizeof(sin)) 
	CL_SOCKET ειναι το file descriptor του socket που δημιουργηθηκε με την socket(). (struct 
	sockaddr *)&sin ειναι ενας δεικτης σε ενα struct sockaddr αντικειμενο που αντιπροσωπευει 
	την local addr που ειναι bound το socket. Σε εμας, ειναι pointer στο sin structure που 
	ειναι ειδους struct sockaddr_in οποτε πρεπει να το μετατρεψουμε (να κανουμε cast) σε ειδος 
	struct sockaddr για να το δεχτει η bind(). To local address για εμας ειναι  INADDR_ANY που 
	σημαινει οτι δεχομαστε συνδεσεις απο οποιοδηποτε address. 

7. Ειναι αναγκαστικο να κάνουμε bind στον client?
	Οχι, ο kernel μπορει να διαλάξει απο μόνος του ενα port ωστε να μπορεί το κανάλι 
	επικοινωνίας να ταυτοποιηθεί μονοσήμαντα
	Μπορει να χρησιμοποιηθεί για να ορίζει συγκεκριμένα ποια port και address θες να 
	χρησιμοποιήσεις τοπικά

	Ο server ειναι αναγκασμενος να κανει bind, δηλαδή να “ενωσει” το καναλι επικοινωνιας με το 
	socket που εχει φτιαξει. 

8. sockaddr:
    Ουσιαστικά μια δομή που ειδικευεται στην μεταφορά
    address και ports για AF_INET address family  
	Αντιπροσωπευουν network addresses.
	H sockaddr δομη αντιπροσωπεύει μια γενικη δομη.
	Εχει τα παρακατω members:
	-sa_family: μια οικογενεια διευθυνσεων που μας δειχνει το ειδος της διευθυνσης (πχ AF_INET 
		για IPv4, AF_INET6 για IPv6).
	-sa_data: Ενα array για να αποθηκευουμε τα δεδομενα για το address. 

9. sockaddr_in:
	η sockaddr_in δομη ειναι μια συγκεκριμενη μορφη του sockaddr για IPv4 διευθυνσεις. 
	Εχει τα ακολουθα μελη:
	-sin_family: ειναι μια οικογενεια διευθυνσεων που εχει ειδος AF_INET για IPv4.
	-sin_port: O αριθμος της θυρας σε network byte order (χρησιμοποιουμε την htons για 
		μετατροπη απο host byte order). Μπορεί να έχει την τιμή 0, οπότε διαλέγει το 
		σύστημα ένα ελεύθερο port (> 1024).
	-sin_addr: IPv4 διευθυνση (32 bits) (internet διευθυνση μηχανης)
	-sin_zero: Αυτός είναι ένας πίνακας 8 χαρακτήρων του οποίου ο μόνος σκοπός είναι να 
		εξισορροπήσει το μέγεθος της δομής

	Στην περίπτωση μας, το sockaddr_in struct χρησιμοποιειται για δυο λογους. Για να 
	παρουσιάσουμε την τοπικη διευθυνση “sin” με την οποια κανει bind() ο client και για να 
	αναπαραστήσουμε την απομακρυσμενη διευθυνση “sin2” του host με την οποια ο client socket 
	θα συνδεθει με την connect(). 

	Οταν δινουμε ως ορισμα την sockaddr_in σε συναρτήσεις, συνηθως κανουμε cast σε (struct sockaddr*) δηλαδη μετατρεπουμε το ειδος τους για να ικανοποιήσουμε τον τυπο παραμετρου της συναρτησης. 

	Το πρώτο πεδίο sin_family πρέπει να είναι ίδιο µε την παράμετρο
	domain κατά την δημιουργία του socket.
	Το πεδίο sin_port καθορίζει το port number του socket και δεν
	πρέπει να χρησιμοποιείται από κάποιο άλλο socket. 
	Το sin_addr είναι η internet διεύθυνση της μηχανής
	στην οποία θα δέχεται συνδέσεις το socket. Αν π.χ. µία μηχανή
	είναι συνδεδεμένη ταυτόχρονα σε περισσότερα από ένα δίκτυα,
	τότε το socket μπορεί να προσδιορίσει από ποιο δίκτυο µόνο θα 
	δέχεται συνδέσεις. Συνήθως όμως χρησιμοποιείται η τιμή
	INADDR_ANY, που σημαίνει ότι δεχόμαστε συνδέσεις από παντού.

10. Διαφορες sockaddr και sockaddr_in:
	H sockaddr ειναι ενας γενικος τροπος περιγραφης οποιουδηποτε ειδους socket operation ενω 
	το sockaddr_in ειναι εξελιξη του sockaddr και αναφερετε συγκεκριμενα σε IP βασισμενες 
	επικοινωνιες. 
	Μπορουμε δλδ να του δωσουμε περισσότερες πληροφορίες

11.connect:
    Μια διεργασία-πελάτης µπορεί να ζητήσει σύνδεση µε κάποιον
    εξυπηρετητή µε χρήση της κλήσης connect():
    int connect(int sd, struct sockaddr *addr, int addrlen); 

12.System Call connect
     Περιέχεται στο <sys/socket.h>
      Ουσιαστικά ενώνει το socket που δηλώνει ο file descriptor και την διευθυνση η οποία 
      προσδιορίζεται απο ενα sockaddr struct ***
      (Προεραιτικό)
      [Αν το socket έχει type SOCK_STREAM οπως το δικό μας, τότε αυτο το system call προσπαθεί να 
		κάνει μια σύνδεση με το socket το οποίο ειναι δεμένο με την διευθυνση που 
		προσδιορίζει το sockaddr struct.]
	3 Ορίσματα:
	- Socket File Descriptor
		Ειναι ο file descriptor του socket για το οποίο θέλουμε να κάνουμε την συνδεση
	- Ειναι ενας pointer σε ενα sockaddr struct το οποίο περιέχει πληροφορίες για την ένωση 
		την οποία θέλουμε 
	- Ενα int το οποίο δείχνει το μέγεθος του struct που αναφέραμε πριν
	
	* παρατήρηση 2
	Return Value:
		Στη επιτυχία επιστρεφει 0 στην αποτυχια επιστρεφει -1
	Παρατηρήσεις:
	1. Στην δικιά μας περίπτωση οταν περνάμε το 2ο όρισμα πρέπει πρώτα να κάνουμε ενα cast, 
		δηλαδή σε μια μετατροπή σε sockaddr struct καθώς το sin που χρησιμοποιούμε ειναι 
		sockaddr_in struct. ΑΝ δεν το κάνουμε και πάλι δουλευει αλλά βγάζει warning
	2. Για αυτόν τον λόγο φτιάχνουμε ενα νεο struct sockaddr_in το οποίο έχει s_addr την 
		διευθυνση του host, 


13.gethostbyname:
	Είναι ένα (παλιό) function της C.
	Παιρνει ως όρισμα το ονομα του host και επιστρεφει εναν 
	δεικτη σε ενα ‘struct hostent’ το οποιο περιεχει πληροφοριες
	για τον host.
	Στην επιτυχια επιστρεφει το hostent structure και 
	στην αποτυχια εναν null pointer. 

14.hostent:
	Ειναι ενα data structure που οριζεται στο header <netdb.h>.
	Περιέχει πληροφορίες για τον host οπως:
		h_name :	ένας δείκτης σε μια συμβολοσειρά που 
		    	αντιπροσωπεύει το επίσημο όνομα του host
		h_aliases: 	ένας δείκτης σε μια συμβολοσειρά που 
			αντιπροσωπεύει τα εναλλακτικα ονοματα του host
		h_addrtype: 	Καθορίζει τον τύπο διεύθυνσης, όπως AF_INET 
			για IPv4 ή AF_INET6 για IPv6.
		h_length:  	μας δείχνει  το μήκος της διεύθυνσης σε byte.
		h_addr_list : 	ενα array απο διευθυνσεις δικτυου για τον host. 
	Οι διευθύνσεις επιστρέφονται με network byte order.

	Σημειωση: το struct hostent ειναι μερος ενος παλαιοτερου 
	μηχανισμου του IPv4 και θεωρειται καταργημενος. 
	Πιο συγχρονα χρησιμοποιειται η συναρτηση getaddrinfo.
	
15.accept:
	Σε επίπεδο server
	O server  περιμένει μέχρι να υπαρξει καποια συνδεση. Μολις ενας client κανει connect ο 
		server δεχεται αυτη την συνδεση
	Αφού μια διεργασία-εξυπηρετητής διευθυνσιοδοτήσει το socket 
	της µε χρήση της bind() μπορεί να δεχτεί κλήσεις σύνδεσης µε
	χρήση της κλήσης accept():
	int accept(int sd, struct sockaddr *addr, int *addrlen);


	H accept ειναι blocking (στις περισσότερες υλοποιήσεις)
	Μπλοκαρει τον server μεχρι να βρεθει μια συνδεση

	αυτο το κάνουν αυτοί αρα δεν μας νοιάζει

16.memset:
	Ειναι ενα function που χρησιμοποιείται για να βαλουμε μια 
	συγκεκριμένη τιμή σε ένα μπλοκ μνήμης. Ο σκοπός του 
	είναι να αρχικοποιήσει ή να διαγράψει ένα μπλοκ μνήμης
	θετοντας όλα τα byte του σε μια δεδομένη τιμή.


	void *memset(void *str, int c, size_t n)
    Parameters: 
	-str:	ενα pointer σε memory block το οποιο θα γεμισει
	-c: 	η τιμη που θα βαλουμε στο block. Εμεις το δινουμε σε 
		μορφη int αλλα η συναρτηση γεμιζει το block με την 
		μετατροπη του σε unsigned char.
	-n:	ο αριθμος των byte που θα γινουν set

	Αυτή η συνάρτηση επιστρέφει έναν δείκτη στην περιοχή μνήμης str.

	Στην περιπτωση μας, η memset(&sin2, '\0', sizeof(sin2)) χρησιμοποιειται 
	για να αρχικοποιήσετε το sin2 structure ολο σε μηδενικα πριν αντιγράψουμε
	τη διευθυνση IP σε αυτο.

17.memcpy:
	To function memcpy χρησιμοποιείται για την αντιγραφή ενός 
	memory μπλοκ(μια ακολουθία byte) από μια θέση σε μια άλλη.

	void *memcpy(void *dest, const void * src, size_t n)
    Parameters:
	-dest:	Ενας pointer στο array προορισμο που θα αντιγράψουμε 
	τα δεδομενα.
	-src:	είναι ένας δείκτης στο memory μπλοκ από όπου θα 
	αντιγραφούν τα δεδομένα.
	-n:	είναι ο αριθμός των byte που πρέπει να αντιγραφούν.

	size_t datatype χρησιμοποιείται για να αναπαράσταση μεγέθους
	ενος allocated block της μνήμης
	Αυτή η συνάρτηση επιστρέφει έναν δείκτη στον προορισμό που είναι str1

	Στην περιπτωση μας, η memcpy((char *) &sin2.sin_addr.s_addr, host_address->h_addr_list[0], 
		host_address->h_length) 
	αυτη η γραμμη αντιγράφει τη διεύθυνση IP από το struct host_address στο member sin2.sin_addr.s_addr του struct sin2

18.htonl, htons, ntohl, ntohs:
	functions για μετατροπη byte order μεταξύ host και network
	ειναι στο #include <arpa/inet.h> header
	μετατροπη ενος int από host byte order σε network byte order.
	Network byte order είναι μια standard σειρα bytes για 
	μεταδοση δεδομενων στο διαδικτυο
	Επομένως θέλουμε να φέρουμε τις τιμές σε κατάλληλη μορφή ωστε να τις χρησιμοποιήσουμε 	
	σωστά
-htons:
	Δεχεται: 16-bit unsigned long int σε σειρά byte host
	Επιστρεφει: 16-bit unsigned long int σε σειρά byte network
	Σκοπός: Μετατρέπει τη σειρά byte μιας 32 bit τιμής (συνήθως port number)
	Χρήση: Συνήθως χρησιμοποιείται για αριθμούς θυρών.


	Η συνάρτηση htons χρησιμοποιείται συνήθως όταν θελουμε 
	network communication, όπως τον καθορισμό των αριθμών
	των θυρών ή IP διευθύνσεις 
	Parameters: 
	
-hostsport:	ειναι το unsigned short int σε σειρα byte host.	
	Στην περιπτωση μας, το htons χρησιμοποιείται για τη 
	μετατροπή της μεταβλητής port η οποία περιέχει τον 
	αριθμό θύρας, από σειρά byte host σε σειρά byte network. 
	Ετσι διασφαλίζουμε ότι ο αριθμός θύρας αναπαρίσταται 
	σωστά σε σειρά byte network, δλδ σε σωστή μορφη.

-htonl:
	Δεχεται: 32-bit unsigned long int σε σειρά byte host
	Επιστρεφει: 32-bit unsigned long int σε σειρά byte network
	Σκοπός: Μετατρέπει τη σειρά byte μιας 32 bit τιμής 
	(συνήθως μια διεύθυνση IP) από σειρά byte host
	 σε σειρά byte network.
	Χρήση: Συνήθως χρησιμοποιείται για διευθύνσεις IP.

	Στην περιπτωση μας, το htonl χρησιμοποιείται για να 
	μετατρεψει την σταθερά INADDR_ANY, η οποία 
	αντιπροσωπεύει οποιαδήποτε διεύθυνση IP,  απο host 
	byte order σε network byte order. Στη συνέχεια, το 
	αποτέλεσμα αποθηκευεται στο sin.sin_addr.s_addr 
	που που αντιπροσωπεύει τη διεύθυνση IP για τη 
	σύνδεση του socket.

	Η κύρια διαφορά μεταξύ htonl και htons βρισκεται στο
	μέγεθος των δεδομένων που διαχειριζονται. 
	Γενικά, Πρεπει να έχουν μορφή η οποία είναι αποδεκτή από 
	οποιαδήποτε μηχανή συνδέεται σε δίκτυο ωστε να μην υπαρχουν
	ασυμβατότητες. Για αυτο χρησιμοποιώ τις htons και htonl

sin.sin_addr.s_addr = htonl(INADDR_ANY); ορίζει τη 
διεύθυνση IP για το socket. Χρησιμοποιεί htonl για να 
μετατρέψει τη διεύθυνση IP από host byte order σε network 
byte order.Το INADDR_ANY είναι μια σταθερά που αντιπροσωπεύει
 οποιαδήποτε διεύθυνση IP. Με τη χρηση του INADDR_ANY, το 
socket μπορεί να δέχεται συνδέσεις από παντου.

19.shutdown: 
	ειναι ενα function που διακοπτει ολοκληρη ή μερική διαδική συνδεση (client και host)
	παιρνει ως όρισμα το socket descriptor και εναν int που μας δειχνει τον τροπο που κανει 
	shutdown . Εμεις χρησιμοποιουμε το int 2 το οποιο μπλοκαρει την επικοινωνια απο και προς 
	το socket μας.


20.Select
	int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict 
		exceptfds, struct timeval *restrict timeout);

-Τι κανει:
	Ειναι ενα system call που περιεχεται στη βιβλ <sys/select> Η select επιτρεπει σε ενα 
	προγραμμα να κανει monitor πολλαπλους file descriptors περιμένοντας ενας ή περισσοτεροι 
	απο αυτους να γινους "ready" για καποια Ι/Ο operation (e.g. reading, writing, or error 
	handling). 
	Οταν κληθει η select περιμένει!!(δεν μπλοκάρει γιατι ελεγχει πολλα file descs) μεχρι ενα ή 
	περισσοτερα fds γινουν "ετοιμα" για I/O.
	Οταν επιστρεψει τοτε το προγραμμα μπορει να εκτελεσει τα καταλληλα I/O operations.
-Τι επιστρεφει:
	Επιστρεφει -1 στο error, 0 στο timeout και on success επιστρεφει τον αριθμο των file 
	descriptors που ειναι ετοιμα για I/O operations.
-Tι arguments δεχεται:
	Παιρνει 5 arguments
	α.nfds που ειναι ενα int που περιεχει την μεγαλυτερη τιμη που αντιστοιχει σε file  
	descriptor συν 1 (the highest numbered of file descriptors)

Specifies how many descriptors should be examined. The descriptors checked are 0 through nfds-1.

	β.readfds εναν pointer στο set με τα file descriptors που θα ελεγχθουν για το αν 
			θα ειναι ετοιμα για read
	γ.writefds εναν pointer στο set με τα file descriptors που θα ελεγχθουν για το αν 
			θα ειναι ετοιμα για write
	δ.exceptfds εναν pointer στο set με τα file descriptors που θα ελεγχθουν για το αν 
			θα ειναι ετοιμα για exceptions
	ε.timeout εναν pointer στο struct timeval που μας δινει τον max χρονο που η select 
	θα περιμενει για ετοιμοτητα.
	 Αν η timeout ειναι null, η select θα blockαρει για παντα μεχρι καποιο file descriptor 
	 	γινει ετοιμο. Αν το timeout ειναι 0 τοτε η select θα επιστρεψει κατευθειαν. πχ αν 
	 	θελουμε να κανει block 

Λέμε οτι ελέγχουμε αν το file descriptor ειναι ακομα μερος τους σετ γιατι η select αλλάζει τα 
	περιεχόμενα του set. Για αυτό τα ξαναορίζουμε απο την αρχή σε κάθε επανάληψη στο 
	πρόγραμμα!




