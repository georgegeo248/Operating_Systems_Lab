ουσιαστικα μιλαμε για ενα αρχείο! Οταν κανοουμε read πχ 4 bytes σβήνουμε απο το ασχείο αυτο τα πρώτα 4 bytes καθώς τα διαβάζουμε (FIFO)

1. Pipes 
    Προγραμματιστική τεχνική ωστε να μεταφέρουν οι διεργασίες δεδομένα και να επικοινωνουν
    Ουσιαστικά πρόκειται για ενα κανάλι επικοινωνλιας 
    Υπαρχουν 2 ειδη:    Επώνυμες / Κοινές
    	Επωνημες: Δεν χρειάζεται η σχεση parent-child / Αμφίδρομες
    Εμεις χρησιμοποιούμε κοινές σωληνώσεις όπου:
        α. Ακολουθούν τυπικό τρόπο παραγωγού-καταναλωτή
        β. Ο παραγωγός γράφει στο ένα ακρο και ο καταναλωτής διαβάζει απο το άλλο
        γ. Ειναι δηλαδη μονής κατευθυνσης
        δ. Απαιτείται σχέση γονέα-παιδιού
    Μια σωλήνωση χαρακτηρίζεται απο 2 άκρα -> read-end(0) και write-end(1)
    Σημείωση: Μπορει οποιαδήπτε διεργασία γνωρίζει αυτά τα άκρα να αναλάβει τον ρόλο του παραγωγού 	
    	ή του καταναλωτή

2. Ποσα pipes χρησιμοποιούμε 
    n ωστε να επικοινωνεί ο πατερας με τα παιδια 
    n ωστε να επικοινωνουν τα παιδια με τον πατέρα
    Αρα συνολικά 2n pipes -> n για κάθε δουλειά!
    //Θα μπορούσαμε να χρησιμοποιήσουμε και μόνο n αλλα θα χρειαζόταν χρονοπρογραμματισμός δλδ 
    	//συγχρονισμός  
    (Χρονοπρογραμματισμος->συντονισμός συνύπαρξης πολλαπλών διεργασιών στην μνήμη του υπολογιστή/ 
    	απο το ΛΣ)
    
    Στα in_pipes -> Γράφει ο πατέρας / Διαβάζουν τα παιδιά
    Στα out-Pipes -> Γράφουν τα παιδιά / Διαβάζει ο πατέρας
    
    -Γιατι χρησιμοποιείται 2 σωληνώσεις σε κάθε παιδί:
    	Θέλουμε να μην υπαρξει μπερδεμα στην αναγνωση και εγγραφη δεδομένων καθώς και οι 
    		2 διεργασιες ανταλλάσσουν δεδομένα. Θεωρητικά για την επικοινωνία 2 διεργασιών
    		χρειάζεται 1 σωλήνωση ωστόσο αν δεν υπάρχει συχρονισμός των διεργασιων θα 
    		προκύψουν προβλήματα. Κατι τετοιο ειχαμε αναλύσει και στην παρουσίαση της 
    		ασκησης οπου ειχαμε πέσει πάνω στο πρόβημα οπου ο πατέρας πχ διάβαζε τα δεδομένα
    		που ο ίδιος ειχε γράψει στο pipe. Για να μην συμβαινει αυτο χρειάζεται είτε 
    		συχρονισμός είτε μια άλλη νοοτροπία,την οποια εμεις ακολουθήσαμε με ξεχωριστά 
    		pipe για κάθε δουλειά.
    	\/\/\/
	Το προβλημα που θέλαμε να αποφύγουμε ειανι αυτο που αναλύσαμε και στην παρουσίαση 
	της ασκησης, δλδ το προβλημα συχρονισμου. Αν δεν εχουμε συχρονισμο μπορει να 
	υπαρξει μπερδεμα ποια διεργασία διάβασε κάτι και ποτε. Αυτο λυνεται με συχρονισμο 
	των διεργασιων 
	Ωστόσο εμεις επιλε´ξαμε να ακολουθήσουμε λογική με 2 sets arrays
	/\/\/\
    

    
    - Τι θέλουμε να αποφύγουμε - Γιατι χρησιμοποιούμε την close():
    	Ουσιαστικά θέλουμε 
    	σχετικα με τα in_pipes, ο πατέρας να μην διαβάζει απο το pipe που γράφει 
    	και το παιδί να μην γράφει στο pipe απο το οποίο διαβάζει 
    
    	σχετικά με τα out_pipes θέλουμε ο πατέρας να μην γράφει στα pipes απο τα οποία διαβάζει 
    	και το παιδί να μην διαβάζει απο το pipe που γραφει
	
    - Γιατι δυο διαστάσεων πίνακες:
    	Επειδή εμείς έχουμε πολλά παιδιά φτιαχνουμε εναν πίνακα 2 διαστάσεων στο οποίο έχουμε όλυς 	
    		τους πίνακες των pipes. Αρα έχουμε εναν πίνακα n*2 δηλαδή n γραμμές 
    		και 2 στήλες. -> αυτό για τα input_pipes
    		Ουσιαστικά η γραμμή i αντιστοιχεί σε σωλήνωση με το i παιδί
    	Επίσης φτιάχνουμε εναν ίδιο πίνακα 2 διαστάσεων για τα οut_pipes
    
    - Μπορούν τα παιδια και ο πατεράς να γράφουν και να διαβάζουν στο ίδιο pipe?
   	 Ναι γιατι τα άκρα τα ξέρουν και οι δυο γιατι φρόντισα να κάνω την σωλήνωση πριν το fork 
   	 οπότε ολοι κληρψνόμησαν αυτη την πληροφορία 

3. κλήση συστήματος pipe()
	int pipe(int pipefd[2]);
	
	- Τι κάνει;
		Δημιουργεί μια σωλήνωση που χρησιμοποιείται για επικοινωνία μεταξύ των διεργασιών
		O πίνακας που παίρνει ως όρισμα χρησιμοποείται για να επιστρεψει 2 file 
		descriptors τα οποία αναφέρονται στην αρχή και στο τέλος του pipe 
		Το pipefd[0] -> read-end
		Το pipefd[1] -> write-end 
	- Τι επιστρέφει;
		Επιτυχία -> 0
		Αποτυχία -> -1
	- Τι ορίσματα έχει;
	ενα ορισμα -> την διευθυνση ενος πίνακα 2 ακεραίων
	παιρνει την διευθυνση και ορίζει δυο άκρα
	Στην διευθυνση που πήρε βάζει το άκρο αναγνωσης και στην επόμενη διευθυνση βάζει το 
		ακρο εγγραφης
	Αν βάλλω το όνομα του πίνακα ειναι σαν να βλαζω την διευθυνση του fd[0],
		οχι το περιεχόμενο
	
	Eιναι μονής κατευθυνσης  δλδ : Αν ο πατέρας θέλει να διαβάσει θα παει στο fd[0] και αν 
		το παιδί θέλει να διαβάσει θα πάει και αυτό στο fd[0]  

4. Select
	int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, 
		fd_set *restrict exceptfds, struct timeval *restrict timeout);

	-Τι κανει:
		Η select επιτρεπει σε ενα προγραμμα να κανει monitor πολλαπλους file descriptors 
		περιμένοντας ενας ή περισσοτεροι απο αυτους να γινους "ready" για καποια Ι/Ο 
		operation (e.g. reading, writing, or error handling). Ειναι ενα system call που 
		περιεχεται στη βιβλ <sys/select> 
		Οταν κληθει η select περιμένει!!(δεν μπλοκάρει) μεχρι ενα ή περισσοτερα fds γινουν 
		"ετοιμα" για I/O.
		Οταν επιστρεψει τοτε το προγραμμα μπορει να εκτελεσει τα καταλληλα I/O operations.
	-Τι επιστρεφει:
		Επιστρεφει -1 στο error, 0 στο timeout και on success επιστρεφει τον αριθμο των 
		file descriptors που ειναι ετοιμα για I/O operations.
	-Tι arguments δεχεται:
		Παιρνει 5 arguments
		α.nfds που ειναι ενα int που περιεχει την μεγαλυτερη τιμη που αντιστοιχει σε file 
		  descriptor συν 1 (the highest numbered of file descriptors)
		  Ουσιαστικά εξηγεί πόσα desctriptos πρεπει να εξεταζονται. Απο 0 εως το nfds
		β.readfds εναν pointer στο set με τα file descriptors που θα ελεγχθουν για το αν 
			θα ειναι ετοιμα για read
		γ.writefds εναν pointer στο set με τα file descriptors που θα ελεγχθουν για το αν 
			θα ειναι ετοιμα για write
		δ.exceptfds εναν pointer στο set με τα file descriptors που θα ελεγχθουν για το αν 
			θα ειναι ετοιμα για exceptions
		ε.timeout εναν pointer στο struct timeval που μας δινει τον max χρονο που η select 
			θα περιμενει για ετοιμοτητα.
	 		Αν η timeout ειναι null, η select θα περιμένει για παντα μεχρι καποιο file 
	 		descriptor γινει ετοιμο. Αν το timeout ειναι 0 τοτε η select θα επιστρεψει 
	 		κατευθειαν. πχ αν θελουμε να κανει block 
			για 2 sec κανω:
				struct timeval timeout = {2, 0};
				int select_retval = select(max_fd, &read_fds, NULL, NULL, 
					&timeout);
		

5.File descriptors
	-Tι ειναι:
		Στα Unix λειτουργικα συστηματα ολα αντιμετωπιζονται ως αρχεια. File descriptor 
			ειναι ενα int value που αναφερεται σε ενα ανοιχτο αρχειο ή ενα pipe ή σε 
			ενα network socket ή σε ενα αλλο I/O resource. 
		Χρησιμοποιουνται για να διαβασουμε, γραψουμε και τροποποιησουμε ροες δεδομενων 
			στην C. 
		Χρησιμοποιουμε το header unistd.h.
		Ουσιαστικά ειναι ενας integer ο οποιος αντιστοιχίζεται μοναδικά σε ενα ανοιτκό
		αρχείο
		Χρησιμοποιούνται για ταυτοποιήσουμε ανοικτά αρχεία.
		Χρησιμοποιούνται απο διάφορα system calls , οπως read και write, για 
			υλοποίηση I/Ο operations
		Κάθε φορά που ανοίγει ενα αρχείο αντιστοιχίζεται σε αυτό και ενας file 
		descriptor
		
		Καθε φορα που ανοιγει ενα προγραμμα υπαρχουν 3 standar file descriptors
		- standard input (stdin) - standard output (stdout) - standard error (stderr)
		
		Απο εκει και περα μπορόυμε να τα βάλλουμε σε file descriptor sets ωστε να τα 
		χρησιμοποιεί η select()
	
6.File descriptor sets
	-Τι ειναι:
		Ειναι ενα data stracture (δομη δεδομένων) που χρησιμοποιειται απο διαφορα system 
		calls για να αντιπροσωπευσουν ενα set απο file descriptors. Ειναι μια συλλογη απο 
		file descriptors.
		
		Ενα file descriptor set συνηθως οριζεται ως ενα array απο bits 
		[οπου καθε bit του 
		array αντιστοιχει σε ενα file descriptor. Το bit παιρνει τιμη 1 αν το αντιστοιχο 
		file desc ειναι μελος του set και 0 οταν δεν ειναι]
		
		Στη C τα file descriptor sets αντιπροσωπευονται με το fd_set data type το οποιο 
		οριζεται στο header 
		<sys/select.h>. 

		Με την χρηση καποιων macros εντολων μπορουμε να ελεγχουμε τα fd sets.

	-Μερικα απο τα macros ειναι:
		α. FD_ZERO(fd_set *set): αυτο το macro αρχικοποιει το set σε ενα αδειο set (κανει 
			clear ολα τα bits)
		β. FD_SET(int fd, fd_set *set): αυτο το macro προσθετει ενα file descriptor στο 
			set θετοντας το αντιστοιχο bit στο set 1.
		γ. FD_ISSET(int fd, fd_set *set): αυτο το macro ελεγχει αν ενα file descriptor 
			ειναι ακόμα μελος ενος set ελεγχοντας το αντιστοιχο bit στο set. Αν το bit 
			ειναι 1, το fd ειναι μελος του σετ, αλλιως οχι.
			Λέμε οτι ελέγχουμε αν το file descriptor ειναι ακομα μερος τους σετ γιατι 	
			η select αλλάζει τα περιεχόμενα του set. Για αυτό τα ξαναορίζουμε απο την
			αρχή σε κάθε επανάληψη στο πρόγραμμα!
		δ. FD_CLR(fd, &fdset)  
			Clears the bit for the file descriptor fd in the file descriptor set 
			fdset.
			
		To STDIN_FILENO ειναι μια προκαθορισμενη σταθερα στην C που αντιπροσωπευει 
		το file descriptor για standar input που τυπικα ειναι το πληκτρολογιο. 
		
		Τα macros αυτα χρησιμοποιουνται σε συνδιασμο με τη select για να προσδιορισουμε 
		ποια file descriptors θα χρησιμοποιηθουν και που.

7. write
	ssize_t write(int fd, const void *buf, size_t count);
	 #ssize_t χρησιμοποιείται για να αναπαράσταση μεγλέθοςυ ενος allocated block της μνήμης
	- Τι κάνει;
		Κάνει εγγραφη μέχρι ενα συγκεκριμένο αριθμό bytes (3o ορισμα) ξεκινώντας απο την 
		διευθυνση του buffer(2ο ορισμα) στο αρχείο που ορίζει ο file descriptor(1ο ορισμα)
		
		Μπορεί να γράψει λιγότερα απο τα bytes που ορίζει το count αν δεν υπάρχει χώρος
		στον buffer ή αν εγινε διακοπή απο κάποιο signal ενώ εγραφε
	- Τι επιστρέφει;
		Επιτυχία ->  αριθμό bytes που γράφτηκαν
		Αποτυχία -> -1
	- Τι arguments εχει;
		1. file descriptor
		2. διευθυνση του buffer
		3. αριθμός bytes
	- FIFO
		Οτι μπαινει πρώτο μετά θα βγεί και πρώτο. ΔΛΔ γραφεται στο τέλος
		
	

8. read
	 ssize_t read(int fd, void *buf, size_t count);
	 #ssize_t χρησιμοποιείται για να αναπαράσταση μεγλέθοςυ ενος allocated block της μνήμης
	-Τι κάνει:
	  Προσπαθεί να διαβάσει συγκεκριμνένο αριθμό απο bytes απο το αρχείο που αναφέρται ο 
	  file descriptor και να τα γράψει μέσα σε εναν buffer
	-Tι επιστρέφει:
	  Στην επιτυχία επιστρέφει τον αριθμό bytes (τυπου ssize_t)που διάβασε και επισης το file 
	  position προχωράει κατά αυτόν τον αριθμό. Ουσιαστικά οταν διαβάζω κάτι με την read το 
	  ξυλώνω, δηλαδη το αφαιρώ
	  (ο αριθμός των bytes μπορει να ειανι μικρότερος απο αυτον που ζήτησα εαν εχει γινει 
	  	κάποιο signal interruption)
	  Στην αποτυχία επιστρέφει -1
	-Blocking 
	  Αν η σωλήνωση ειναι αδεια τότε οτι η διεργασία κολλάει γιατι περιμένι να διαβάσει κάτι
	
	##stackoverflow
	Yes, EOF will cause read() to return immediately, not block. When you reach EOF read() 
	doesn't wait for more data to be written to the file; it returns 0 bytes immediately. 
	Blocking does not come into play when reading from on-disk files, aside from the usually 
	imperceptible delay when data on disk is read into memory.
	It's more relevant when working with TTYs, sockets, and pipes. For instance, reading from 
	stdin when stdin is connected to the terminal will block until the user types something. 
	Reading from a socket will block if we haven't received data from the other side. Reading 
	from a pipe will block until the program on the other side of the pipe writes something.
	
	-3 arguments:
	 1o: ο file descriptor απο τον οποίο θα διαβάσει
	 2o: Το δευτερο argument ειναι η διευθυνση του buffer οπου θα αποθηκευσουμε το περιεχόμενο
	 3o: Ειναι ο αριθμός των bytes τα οποία θα προσπαθήσει να διαβάσει
	 	Αν στο pipe ειναι λιγότερα bytes απο αυτα που ζήτησα τότε η read blockαρει μέχρι
	 	ικανοποιηθεί ο αριθμός των bytes

9. close() system call
	- Τι κάνει;
		Κλείνει ενα file descriptor ετσι ώστε να μην αναφέρεται πλέον σε καποιο αρχείο 
		ωστε να μην ξαναχρησιμοποιηθεί
		Ουσιαστικά στην υλοποιηση μας αποτρέπει καποια λειτουργία (διαβασμα ή γραψιμο) 
		σε κάποια σωλήνωση
	- Τι επιστρεφει;
		Επιτυχια -> 0
		Αποτυχία -> -1
	- Arguments
		1. To int του file descriptor που θέλουμε να κλείσουμε




